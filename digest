/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   algo.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: blamotte <blamotte@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/15 04:16:10 by blamotte          #+#    #+#             */
/*   Updated: 2026/01/06 21:01:08 by blamotte         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "push_swap.h"
#define DEPTH 1
#define CANDIDATES 1
int adapt_chunk_size(int chunk_size, int initial_chunk, t_stack **a)
{
    if (chunk_size > initial_chunk / 2 && chunk_size > get_stack_size(*a) / 5)
        return (chunk_size * 6 / 7);
    else if (chunk_size > 2)
        return (--chunk_size);
    return (chunk_size);
}

void k_sorting(t_stack **a, t_stack **b, t_list **instructions, int size)
{
	int chunk_size;
	int initial_chunk;
    int threshold;
    int moved;

    threshold = 0;
    (1 && (chunk_size = size / 6), (initial_chunk = chunk_size));
    while (*a)
    {
        moved = 0;
        while (*a && moved < chunk_size)
        {
            if ((*a)->index <= threshold + chunk_size)
            {
                pb(a, b, instructions);
                if ((*b)->index <= threshold)
                    rb(b, instructions); 
                threshold++;
                moved++;
            }
            else
                ra(a, instructions, 1);
        }
        chunk_size = adapt_chunk_size(chunk_size, initial_chunk, a);
    }
}

int mouv_cost_b(t_stack **b, t_stack *target, int direction)
{
    int f_cost;
    int b_cost;
    t_stack *current;
    t_stack *start;

    if (!b || !*b || !target)
        return (0);
    (1 && (start = *b), (current = *b), (f_cost = 0), (b_cost = 0));
    while (current != target)
    {
        current = current->next;
        f_cost++;
        if (current == start)
            break ;
    }
    current = *b;
    while (current != target)
    {
        (1 && (current = current->prev), (b_cost = b_cost + 1));
        if (current == start)
            break ;
    }
    if (direction)
        return (f_cost);
    return (-b_cost);
}

int mouv_cost_a(t_stack **a, t_stack *target, int size, int direction)
{
    int f_cost;
    int b_cost;
    t_stack *current;
    t_stack *start;

    if (!a || !*a || !target)
        return (0);
    (1 && (start = *a), (current = *a), (f_cost = 0));
    while (f_cost < size && current->value < target->value)
    {
        current = current->next;
        f_cost++;
        if (current == start)
            break ;
    }
    b_cost = size - f_cost;
    if (direction)
        return (f_cost);
    else
        return (-b_cost);
}

int find_insert_pos(t_stack **a, int value, int size)
{
    t_stack *current;
    t_stack *min_node;
    t_stack *max_node;
    int min_pos;
    int i;

    (1 && (current = *a), (min_node = *a), (max_node = *a), (min_pos = 0), (i = 0));
    while (i < size)
    {
        if (current->value < min_node->value)
            (1 && (min_node = current), (min_pos = i));
        if (current->value > max_node->value)
            max_node = current;
        (1 && (current = current->next), (i = i + 1));
    }
    if (value < min_node->value || value > max_node->value)
        return (min_pos);
    (1 && (current = *a), (i = 0));
    while (i < size)
    {
        if (current->value < value && current->next->value > value)
            return (i + 1);
        (1 && (current = current->next), (i = i + 1));
    }
    return (min_pos);
}

void insert_sorted(t_stack **a, t_stack **b, t_list **instructions, int size)
{
    int     pos;
    int     moves;
    int     print;

    print = instructions != 0;
    if (!*a)
        return (pa(a, b, instructions));
    pos = find_insert_pos(a, (*b)->value, size);
    if (pos <= size / 2)
    {
        moves = pos;
        while (moves-- > 0)
            ra(a, instructions, print);
    }
    else
    {
        moves = size - pos;
        while (moves-- > 0)
            rra(a, instructions, print);
    }
    pa(a, b, instructions);
}

void    mouv_up_in_b(int steps, t_stack **a, t_stack **b, t_list **instructions)
{
    while (steps != 0)
    {
        if (steps > 0)
        {
            rb(b, instructions);
            steps--;
        }
        else
        {
            rrb(b, instructions);
            steps++;
        }
    }
    insert_sorted(a, b, instructions, get_stack_size(*a));
}

t_stack *copy_stack(t_stack *stack, int size)
{
    t_stack *new_stack;
    t_stack *current;
    t_stack *new_node;
    int i;
    
    if (!stack)
        return (NULL);
    (1 && (new_stack = NULL), (current = stack), (i = 0));
    while (i < size)
    {
        new_node = malloc(sizeof(t_stack));
        if (!new_node)
            return (NULL);
        (1 && (new_node->value = current->value), (new_node->index = current->index));
        if (!new_stack)
            (1 && (new_stack = new_node), (new_node->next = new_node), (new_node->prev = new_node));
        else
        {
            (1 && (new_node->next = new_stack), (new_node->prev = new_stack->prev));
            (1 && (new_stack->prev->next = new_node), (new_stack->prev = new_node));
        }
        current = current->next;
        i++;
    }
    return (new_stack);
}

void    keep_bests_mouvs(t_mouv new_mouv, t_mouv *mouvs)
{
    int i;
    int j;
    
    i = 0;
    while (i < CANDIDATES)
    {
        if (new_mouv.total_cost < mouvs[i].total_cost)
        {
            j = CANDIDATES - 1;
            while (j > i)
            {
                mouvs[j] = mouvs[j - 1];
                j--;
            }
            mouvs[i] = new_mouv;
            break;
        }
        i++;
    }
}

void    inititalize_mouvs(t_mouv *mouvs)
{
    int i;

    i = CANDIDATES;
    while (i--)
    {
        mouvs[i].total_cost = 2147483647;
        mouvs[i].cost_b = 0;
        mouvs[i].cost_a = 0;
    }
}

void    try_combi(t_stack *a, t_stack *b, t_stack *current, t_mouv *best_for_item)
{
    int costs[4][2];
    int totals[4];
    int i;
    int size_a = get_stack_size(a);

    costs[0][0] = mouv_cost_a(&a, current, size_a, 1);
    costs[0][1] = mouv_cost_b(&b, current, 1);
    totals[0] = ft_max(costs[0][0], costs[0][1]);
    costs[1][0] = mouv_cost_a(&a, current, size_a, 0);
    costs[1][1] = mouv_cost_b(&b, current, 0);
    totals[1] = ft_max(ft_abs(costs[1][0]), ft_abs(costs[1][1]));
    costs[2][0] = mouv_cost_a(&a, current, size_a, 1);
    costs[2][1] = mouv_cost_b(&b, current, 0);
    totals[2] = costs[2][0] + ft_abs(costs[2][1]);
    costs[3][0] = mouv_cost_a(&a, current, size_a, 0);
    costs[3][1] = mouv_cost_b(&b, current, 1);
    totals[3] = ft_abs(costs[3][0]) + costs[3][1];
    best_for_item->total_cost = 2147483647;
    i = 0;
    while (i < 4)
    {
        if (totals[i] < best_for_item->total_cost)
        {
            best_for_item->total_cost = totals[i];
            best_for_item->cost_a = costs[i][0];
            best_for_item->cost_b = costs[i][1];
        }
        i++;
    }
}

void    get_best_mouvs(t_stack *a, t_stack *b, t_mouv *mouvs, int size)
{
    t_stack *current;
    t_mouv  tmp_mouv;

    inititalize_mouvs(mouvs);
    if (!b)
        return ;
    current = b;
    while (size--)
    {
        try_combi(a, b, current, &tmp_mouv);
        keep_bests_mouvs(tmp_mouv, mouvs);
        current = current->next;
    }
}

int evaluate_branch(t_stack *a, t_stack *b, int depth, int size)
{
    t_mouv mouvs[CANDIDATES];
    int min_cost;
    int i;
    t_stack *temp_a;
    t_stack *temp_b;
    int total;
    
    if (!b || depth <= 0)
        return (0);
    get_best_mouvs(a, b, mouvs, size);
    if (depth == 1)
        return (mouvs[0].total_cost);
    min_cost = 2147483647;
    i = 0;
    while (i < CANDIDATES && mouvs[i].total_cost != 2147483647)
    {
        temp_a = copy_stack(a, get_stack_size(a));
        temp_b = copy_stack(b, size);
        mouv_up_in_b(mouvs[i].cost_b, &temp_a, &temp_b, NULL);
        total = mouvs[i].total_cost + evaluate_branch(temp_a, temp_b, depth - 1, size - 1);       
        if (total < min_cost)
            min_cost = total;   
        free_stack(&temp_a);
        free_stack(&temp_b);
        i++;
    }   
    return (min_cost);
}

void reintegrate(t_stack **a, t_stack **b, t_list **instructions, int size)
{
    t_mouv mouvs[CANDIDATES];
    int best_index;
    int best_cost;
    int i;
    int total;
    t_stack *temp_a;
    t_stack *temp_b;
    
    if (!*b)
        return ;
    get_best_mouvs(*a, *b, mouvs, size);
    best_index = 0;
    best_cost = 2147483647;
    i = 0;
    while (i < CANDIDATES && mouvs[i].total_cost != 2147483647)
    {
        temp_a = copy_stack(*a, get_stack_size(*a));
        temp_b = copy_stack(*b, size);
        mouv_up_in_b(mouvs[i].cost_b, &temp_a, &temp_b, NULL);
        total = mouvs[i].total_cost + evaluate_branch(temp_a, temp_b, DEPTH, size - 1);
        if (total < best_cost)
            (1 && (best_cost = total), (best_index = i));   
        free_stack(&temp_a);
        free_stack(&temp_b);
        i++;
    }
    mouv_up_in_b(mouvs[best_index].cost_b, a, b, instructions);
}

void    final_rotate(t_stack **a, t_list **instructions, int size)
{
    int min_pos;
    int i;
    t_stack *current;
    t_stack *min_node;
    
    (1 && (current = *a), (min_node = *a), (min_pos = 0), (i = 0));
    while (i < size)
    {
        if (current->value < min_node->value)
            (1 && (min_node = current), (min_pos = i));
        current = current->next;
        i++;
    }
    if (min_pos <= size / 2)
    {
        while (min_pos-- > 0)
            ra(a, instructions, 1);
    }
    else
    {
        min_pos = size - min_pos;
        while (min_pos-- > 0)
            rra(a, instructions, 1);
    }
}

void algo(t_stack **a, t_stack **b, t_list **instructions)
{
    int size;

    size = get_stack_size(*a);
    k_sorting(a, b, instructions, size);
    while (*b)
    {
        reintegrate(a, b, instructions, get_stack_size(*b));
    }
    final_rotate(a, instructions, size);

}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: blamotte <blamotte@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/12 17:22:33 by blamotte          #+#    #+#             */
/*   Updated: 2026/01/06 18:34:54 by blamotte         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "push_swap.h"
#include <stdio.h>

void	free_stack(t_stack **stack)
{
	t_stack	*tmp;
	t_stack	*current;

	if (!stack || !*stack)
		return ;
	current = *stack;
	if (current->next == current)
	{
		free(current);
		*stack = NULL;
		return ;
	}
	current->prev->next = NULL;
	while (current)
	{
		tmp = current->next;
		free(current);
		current = tmp;
	}
	*stack = NULL;
}

void	print_stack(t_stack *stack)
{
	t_stack	*tmp;

	tmp = stack;
	if (!stack) return ;
	while (1)
	{
		printf("Value: %7d | Index: %7d\n", tmp->value, tmp->index);
		tmp = tmp->next;
		if (tmp == stack)
			break ;
	}
}
void	free_list(t_list *instructions)
{
	t_list	*tmp;

	while (instructions)
	{
		tmp = instructions->next;
		if (instructions->content)
			free(instructions->content);
		free(instructions);
		instructions = tmp;
	}
}

void	push_swap(t_stack **a)
{
	int		size;
	t_stack	*b;
	t_list	*instructions;

	instructions = NULL;
	size = get_stack_size(*a);
	b = NULL;
	if (size <= 1)
		return ;
	if (size == 2)
	{
		if ((*a)->index > (*a)->next->index)
			sa(a, &instructions);
	}
	else if (size == 3)
		sort_three(a, &instructions);
	else if (size <= 5)
		sort_five(a, &b, &instructions);
	else
		algo(a, &b, &instructions);
	free_stack(&b);
	print_list(instructions);
	free_list(instructions);
}

// void	push_swap(t_stack **a)
// {
// 	int		size;
// 	t_stack	*b;

// 	size = get_stack_size(*a);
// 	b = NULL;
// 	if (size <= 1)
// 		return ;
// 	if (size == 2)
// 	{
// 		if ((*a)->index > (*a)->next->index)
// 			sa(a);
// 	}
// 	else if (size == 3)
// 		sort_three(a);
// 	else if (size <= 5)
// 		sort_five(a, &b);
// 	else
// 		algo(a, &b);
// 	free_stack(&b);
// }

int	main(int ac, char **av)
{
	t_stack	*a;

	a = NULL;
	if (ac < 2)
		return (0);
	if (ac == 2)
	{
		av = ft_split(av[1], ' ');
		if (!av)
			return (0);
	}
	else
		av++;
	if (!parsing(av, &a))
	{
		if (ac == 2)
			free(av);
		return (free_stack(&a), write(2, "Error\n", 6));
	}
	push_swap(&a);
//	print_stack(a);
	free_stack(&a);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parsing.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: marvin <marvin@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/12 16:15:02 by blamotte          #+#    #+#             */
/*   Updated: 2026/01/04 23:43:55 by marvin           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "push_swap.h"

int	isvalid(char *arg)
{
	if (!arg)
		return (0);
	while (*arg)
	{
		if (!ft_isdigit(*arg) && !(*arg == '-'))
			return (0);
		arg++;
	}
	return (1);
}

int	is_int_limits(char *arg)
{
	if (!arg)
		return (0);
	if (*arg == '-')
	{
		if (ft_strlen(arg) > 11)
			return (0);
		if (ft_strlen(arg) == 11)
			if (ft_strncmp(arg, "-2147483648", 11) > 0)
				return (0);
		return (1);
	}
	if (ft_strlen(arg) > 10)
		return (0);
	if (ft_strlen(arg) == 10)
		if (ft_strncmp(arg, "2147483647", 10) > 0)
			return (0);
	return (1);
}

void	set_index(t_stack *stack_a)
{
	t_stack	*current;
	t_stack	*compare;
	int		count;

	if (!stack_a)
		return ;
	current = stack_a;
	while (1)
	{
		count = 0;
		compare = stack_a;
		while (1)
		{
			if (compare->value < current->value)
				count++;
			compare = compare->next;
			if (compare == stack_a)
				break ;
		}
		current->index = count;
		current = current->next;
		if (current == stack_a)
			break ;
	}
}

int isdouble(t_stack *a, long nb)
{
    t_stack *tmp;

    if (!a)
        return (0);
    tmp = a;
    while (1)
    {
        if (tmp->value == nb)
            return (1);
        tmp = tmp->next;
        if (tmp == a)
            break ;
    }
    return (0);
}

int	parsing(char **av, t_stack **a)
{
	int		i;
	t_stack	*new;
	long	nbr;

	i = 0;
	while (av[i])
	{
		if (!isvalid(av[i]) || !is_int_limits(av[i]))
			return (0);
		nbr = ft_atoi(av[i]);
		if (isdouble(*a, nbr))
			return (0);
		new = ft_new_node(nbr);
		add_back(a, new);
		i++;
	}
	set_index(*a);
	return (1);
}
#include "push_swap.h"

static void	print_instr(char *instr)
{
	ft_putstr_fd(instr, 1);
	ft_putchar_fd('\n', 1);
}

static int	match_instr(t_list *node, char *instr1, char *instr2)
{
	if (!node || !node->content)
		return (0);
	if (!ft_strncmp((char *)node->content, instr1, 4) ||
		!ft_strncmp((char *)node->content, instr2, 4))
		return (1);
	return (0);
}

void print_multiple_instr(t_list **current, char *instr1, char *instr2, char *instr3)
{
	int instr1_count;
	int instr2_count;

	instr1_count = 0;
	instr2_count = 0;
	while (match_instr(*current, instr1, instr2))
	{
		if (!ft_strncmp((char *)(*current)->content, instr1, 4))
			instr1_count++;
		else
			instr2_count++;
		*current = (*current)->next;
	}
	while (instr1_count > 0 && instr2_count > 0)
	{
		print_instr(instr3);
		instr1_count--;
		instr2_count--;
	}
	while (instr1_count-- > 0)
		print_instr(instr1);
	while (instr2_count-- > 0)
		print_instr(instr2);
}

int is_cancelable(t_list *current)
{
	if (!current || !current->next || !current->content || !current->next->content)
		return (0);
	if ((!ft_strncmp((char *)current->content, "pa", 3) && !ft_strncmp((char *)current->next->content, "pb", 3)) ||
		(!ft_strncmp((char *)current->content, "pb", 3) && !ft_strncmp((char *)current->next->content, "pa", 3)) ||
		(!ft_strncmp((char *)current->content, "ra", 3) && !ft_strncmp((char *)current->next->content, "rra", 4)) ||
		(!ft_strncmp((char *)current->content, "rb", 3) && !ft_strncmp((char *)current->next->content, "rrb", 4)) ||
		(!ft_strncmp((char *)current->content, "rra", 4) && !ft_strncmp((char *)current->next->content, "ra", 3)) ||
		(!ft_strncmp((char *)current->content, "rrb", 4) && !ft_strncmp((char *)current->next->content, "rb", 3)))
		return (1);
	return (0);
}

static int	check_swap_optim(t_list **current)
{
	char	*s1;
	char	*s2;
	char	*s3;

	if (!*current || !(*current)->next || !(*current)->next->next)
		return (0);
	s1 = (char *)(*current)->content;
	s2 = (char *)(*current)->next->content;
	s3 = (char *)(*current)->next->next->content;
	if (s1 && s2 && s3)
	{
		if (!ft_strncmp(s1, "ra", 3) && !ft_strncmp(s2, "pb", 3) && !ft_strncmp(s3, "rra", 4))
		{
			print_instr("sa");
			print_instr("pb");
			*current = (*current)->next->next->next;
			return (1);
		}
		if (!ft_strncmp(s1, "rb", 3) && !ft_strncmp(s2, "pa", 3) && !ft_strncmp(s3, "rrb", 4))
		{
			print_instr("sb");
			print_instr("pa");
			*current = (*current)->next->next->next;
			return (1);
		}
	}
	return (0);
}

void print_list(t_list *instructions)
{
	t_list *current;

	current = instructions;
	while (current)
	{
		if (check_swap_optim(&current))
			continue ;
		if (is_cancelable(current))
			current = current->next->next;
		else if (current->content && (!ft_strncmp((char *)current->content, "ra", 3) || !ft_strncmp((char *)current->content, "rb", 3)))
			print_multiple_instr(&current, "ra", "rb", "rr");
		else if (current->content && (!ft_strncmp((char *)current->content, "rra", 4) || !ft_strncmp((char *)current->content, "rrb", 4)))
			print_multiple_instr(&current, "rra", "rrb", "rrr");
		else
		{
			if (current->content)
				print_instr((char *)current->content);
			current = current->next;
		}
	}
}

void add_instruction(t_list **instructions, char *instr)
{
	t_list *new;
	t_list *tmp;
	char *content;

	new = malloc(sizeof(t_list));
	if (!new)
		return ;
	content = ft_strdup(instr);
	if (!content)
	{
		free(new);
		return ;
	}
	new->content = content;
	new->next = NULL;
	if (!*instructions)
		*instructions = new;
	else
	{
		tmp = *instructions;
		while (tmp->next)
			tmp = tmp->next;
		tmp->next = new;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   push.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: blamotte <blamotte@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/15 03:13:58 by blamotte          #+#    #+#             */
/*   Updated: 2026/01/06 07:58:09 by blamotte         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "push_swap.h"

t_stack	*cut_node(t_stack **stack)
{
	t_stack	*node;

	if (!*stack)
		return (NULL);
	node = *stack;
	if ((*stack)->next == *stack)
		*stack = NULL;
	else
	{
		*stack = node->next;
		node->prev->next = node->next;
		node->next->prev = node->prev;
	}
	node->next = node;
	node->prev = node;
	return (node);
}

void	push_node(t_stack **stack, t_stack *new_node)
{
	t_stack	*tail;

	if (!*stack)
	{
		*stack = new_node;
		new_node->next = new_node;
		new_node->prev = new_node;
	}
	else
	{
		tail = (*stack)->prev;
		tail->next = new_node;
		new_node->prev = tail;
		new_node->next = *stack;
		(*stack)->prev = new_node;
		*stack = new_node;
	}
}

void	pa(t_stack **a, t_stack **b, t_list **instructions)
{
	t_stack	*node;

	if (!*b)
		return ;
	node = cut_node(b);
	push_node(a, node);
	if (instructions)
		ft_lstadd_back(instructions, ft_lstnew(ft_strdup("pa")));
}

void	pb(t_stack **a, t_stack **b, t_list **instructions)
{
	t_stack	*node;

	if (!*a)
		return ;
	node = cut_node(a);
	push_node(b, node);
	ft_lstadd_back(instructions, ft_lstnew(ft_strdup("pb")));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   reverse_rotate.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: blamotte <blamotte@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/15 03:00:21 by blamotte          #+#    #+#             */
/*   Updated: 2026/01/06 07:59:09 by blamotte         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "push_swap.h"

void	rev_rotate(t_stack **stack)
{
	if (!*stack)
		return ;
	*stack = (*stack)->prev;
}

void	rra(t_stack **a, t_list **instructions, int print)
{
	rev_rotate(a);
	if (print)
		ft_lstadd_back(instructions, ft_lstnew(ft_strdup("rra")));
}

void	rrb(t_stack **b, t_list **instructions)
{
	rev_rotate(b);
	if (instructions)
		ft_lstadd_back(instructions, ft_lstnew(ft_strdup("rrb")));
}

void	rrr(t_stack **a, t_stack **b, t_list **instructions)
{
	rev_rotate(a);
	rev_rotate(b);
	ft_lstadd_back(instructions, ft_lstnew(ft_strdup("rrr")));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   rotate.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: blamotte <blamotte@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/15 02:58:16 by blamotte          #+#    #+#             */
/*   Updated: 2026/01/06 07:58:40 by blamotte         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "push_swap.h"

void	rotate(t_stack **stack)
{
	if (!*stack)
		return ;
	*stack = (*stack)->next;
}

void	ra(t_stack **a, t_list **instructions, int print)
{
	rotate(a);
	if (print)
		ft_lstadd_back(instructions, ft_lstnew(ft_strdup("ra")));
}

void	rb(t_stack **b, t_list **instructions)
{
	rotate(b);
	if (instructions)
		ft_lstadd_back(instructions, ft_lstnew(ft_strdup("rb")));
}

void	rr(t_stack **a, t_stack **b, t_list **instructions)
{
	rotate(a);
	rotate(b);
	ft_lstadd_back(instructions, ft_lstnew(ft_strdup("rr")));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   sort_up_to_five.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: blamotte <blamotte@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/15 03:57:27 by blamotte          #+#    #+#             */
/*   Updated: 2026/01/06 07:59:55 by blamotte         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "push_swap.h"

t_stack	*get_max(t_stack *stack)
{
	t_stack	*max;
	t_stack	*tmp;

	if (!stack)
		return (NULL);
	max = stack;
	tmp = stack->next;
	while (tmp != stack)
	{
		if (tmp->index > max->index)
			max = tmp;
		tmp = tmp->next;
	}
	return (max);
}

t_stack	*get_min(t_stack *stack)
{
	t_stack	*min;
	t_stack	*tmp;

	if (!stack)
		return (NULL);
	min = stack;
	tmp = stack->next;
	while (tmp != stack)
	{
		if (tmp->index < min->index)
			min = tmp;
		tmp = tmp->next;
	}
	return (min);
}

void	sort_three(t_stack **a, t_list **instructions)
{
	t_stack	*max;

	max = get_max(*a);
	if (*a == max)
		ra(a, instructions, 1);
	else if ((*a)->next == max)
		rra(a, instructions, 1);
	if ((*a)->index > (*a)->next->index)
		sa(a, instructions);
}

void	put_on_to_top(t_stack **a, t_stack *node, t_list **instructions)
{
	int		size;
	int		i;
	t_stack	*tmp;

	size = get_stack_size(*a);
	i = 0;
	tmp = *a;
	while (tmp != node && i++)
		tmp = tmp->next;
	if (i <= size / 2)
		while (*a != node)
			ra(a, instructions, 1);
	else
		while (*a != node)
			rra(a, instructions, 1);
}

void	sort_five(t_stack **a, t_stack **b, t_list **instructions)
{
	t_stack	*min;

	while (get_stack_size(*a) > 3)
	{
		min = get_min(*a);
		put_on_to_top(a, min, instructions);
		pb(a, b, instructions);
	}
	sort_three(a, instructions);
	while (*b)
		pa(a, b, instructions);
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   swap.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: blamotte <blamotte@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/15 03:05:53 by blamotte          #+#    #+#             */
/*   Updated: 2026/01/06 07:57:02 by blamotte         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "push_swap.h"

void	swap(t_stack *stack)
{
	int	tmp_val;
	int	tmp_index;

	if (!stack || stack->next == stack)
		return ;
	tmp_val = stack->value;
	tmp_index = stack->index;
	stack->value = stack->next->value;
	stack->index = stack->next->index;
	stack->next->value = tmp_val;
	stack->next->index = tmp_index;
}

void	sa(t_stack **a, t_list **instructions)
{
	swap(*a);
	ft_lstadd_back(instructions, ft_lstnew(ft_strdup("sa")));
}

void	sb(t_stack **b, t_list **instructions)
{
	swap(*b);
	ft_lstadd_back(instructions, ft_lstnew(ft_strdup("sb")));
}

void	ss(t_stack **a, t_stack **b, t_list **instructions)
{
	swap(*a);
	swap(*b);
	ft_lstadd_back(instructions, ft_lstnew(ft_strdup("ss")));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils_lst.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: blamotte <blamotte@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/15 00:50:34 by blamotte          #+#    #+#             */
/*   Updated: 2025/12/15 05:10:02 by blamotte         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "push_swap.h"

t_stack	*ft_new_node(int value)
{
	t_stack	*new;

	new = malloc(sizeof(t_stack));
	if (!new)
		return (NULL);
	new->value = value;
	new->index = 0;
	new->next = NULL;
	new->prev = NULL;
	return (new);
}

void	add_back(t_stack **stack, t_stack *new_node)
{
	t_stack	*last;

	if (!new_node)
		return ;
	if (!*stack)
	{
		*stack = new_node;
		new_node->next = new_node;
		new_node->prev = new_node;
	}
	else
	{
		last = (*stack)->prev;
		last->next = new_node;
		new_node->prev = last;
		new_node->next = *stack;
		(*stack)->prev = new_node;
	}
}

int	get_stack_size(t_stack *stack)
{
	t_stack	*tmp;
	int		count;

	if (!stack)
		return (0);
	count = 0;
	tmp = stack;
	while (1)
	{
		count++;
		tmp = tmp->next;
		if (tmp == stack)
			break ;
	}
	return (count);
}
